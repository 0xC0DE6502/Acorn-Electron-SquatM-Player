;SquatM beeper music engine
;Originally written by Shiru 06'17 for ZX Spectrum 48K
;Ported to Atari 8-bit by Shiru 07'21
;Ported to the Acorn Electron by Negative Charge 11'22
;Optimisations of the Acorn Electron version by 0xC0DE 11'22

SHEILA_COUNTER          = &FE06
SHEILA_MISC_CONTROL     = &FE07

SPEAKER_OFF             = %10110001 ; =SPEAKER_ON-1 (!)
SPEAKER_ON              = %10110010

OP_NOP                  = &EA
OP_ROL_A                = &2A

HAS_SAMPLES=0

if HAS_SAMPLES=1
  TRACK=1
  CYCLES=39 ; 39 calibrated with "let's go" track ~2m12
else
  TRACK=1 ; not used at the moment (only 1 track without samples)
  CYCLES=51 ; 51 calibrated with "geostorm" track ~2m08
endif

ORG     &00

.vars_start

.pattern_ptr                            SKIP 2
if HAS_SAMPLES=1
.sample_ptr                             SKIP 2
.sample_mask                            SKIP 1        ;&00 or &80
.sample_bit                             SKIP 1
.sample_out                             SKIP 1
endif
.row_length                             SKIP 1
.row_flags                              SKIP 1
.ch0_acc                                SKIP 2
.ch1_acc                                SKIP 2
.ch2_acc                                SKIP 2
.ch3_acc                                SKIP 2
.ch_mixer                               SKIP 1
.ch_acc                                 SKIP 1
.noise_acc                              SKIP 2
.noise_add_hi                           SKIP 1
.noise_pitch                            SKIP 1
.noise_volume                           SKIP 1
.temp                                   SKIP 1

.tmp_y                                  skip 1

.vars_end

ORG     &E00
GUARD   &5800

.start

    sei                                                     ; Disable interrupts

    lda     #$00
    sta     SHEILA_COUNTER                                  ; Zero the ULA SHEILA counter (FE06), creating a toggle speaker (inaudible frequency)
    tax
.clear_vars
    sta     vars_start,x
    inx
    cpx     #vars_end-vars_start
    bne     clear_vars

    lda     #LO(music_data+2)
    sta     pattern_ptr+0
    lda     #HI(music_data+2)
    sta     pattern_ptr+1
    bne     play_loop ; jump always

.return_loop
    lda     music_data+0
    sta     pattern_ptr+0
    lda     music_data+1
    sta     pattern_ptr+1

.play_loop

    ldy     #0
    lda     (pattern_ptr),y            ;flags DDDN4321 (Drum, Noise, 1-4 channel update)
    sta     row_flags
    iny
    lda     (pattern_ptr),y            ;duration of the row (0=loop), bit 7 percussion
    beq     return_loop
    
    sta     row_length
    iny
    
    lsr     row_flags
    bcc     skip_note_0
    
    lda     (pattern_ptr),y
    iny
    sta     sm_ch0_add0+1
    lda     (pattern_ptr),y
    iny
    sta     sm_ch0_add1+1
    
.skip_note_0

    lsr     row_flags
    bcc     skip_note_1
    
    lda     (pattern_ptr),y
    iny
    sta     sm_ch1_add0+1
    lda     (pattern_ptr),y
    iny
    sta     sm_ch1_add1+1

.skip_note_1

    lsr     row_flags
    bcc     skip_note_2
    
    lda     (pattern_ptr),y
    iny
    sta     sm_ch2_add0+1
    lda     (pattern_ptr),y
    iny
    sta     sm_ch2_add1+1

.skip_note_2

    lsr     row_flags
    bcc     skip_note_3
    
    lda     (pattern_ptr),y
    iny
    sta     sm_ch3_add0+1
    lda     (pattern_ptr),y
    iny
    sta     sm_ch3_add1+1

.skip_note_3

    lsr     row_flags
    bcc     skip_mode_change

    ldx     #OP_NOP
    lda     (pattern_ptr),y
    beq     L4
    ldx     #OP_ROL_A
.L4
    stx     noise_opcode+0
    iny
    iny
    
.skip_mode_change

    ldx     row_flags
    beq     skip_drum

if HAS_SAMPLES=1
    lda     sample_list_lo-1,x
    sta     sample_ptr+0
    lda     sample_list_hi-1,x
    sta     sample_ptr+1
    lda     #$80
    sta     sample_mask
endif

.skip_drum

    lda     row_length
    bpl     skip_percussion
    
    and     #$7f                   ;clear percussion flag
    sta     row_length

    lda     (pattern_ptr),y        ;read noise volume
    iny
    sta     noise_volume
    
    lda     (pattern_ptr),y        ;read noise pitch
    iny

    sty     tmp_y

    sta     noise_pitch
    tay     ; used to be noise_div
    
    lda     #<2174                 ;utz's rand seed
    sta     noise_acc+0
    lda     #>2174
    sta     noise_add_hi
    sta     noise_acc+1
    
  if HAS_SAMPLES=1
    COUNT=((120+37)*2*CYCLES)/56 ; 56c noise_loop, 120+37=157c sound_loop // noise duration, twice as long as inner sound loop
  else
    COUNT=(120*2*CYCLES)/56 ; 56c noise_loop, 120c sound_loop
  endif
  if COUNT>255
    error "COUNT>255!"
  endif
  ldx       #COUNT

; -- 37+14+5 = 56c -------------------------------------------------------------------------------------------
.noise_loop

    dey                            ;2
    beq     noise_update           ;2/3
    ;~5

.noise_skip

    FOR n, 1, 6
      rol temp                     ;5 dummy
    NEXT
    jmp     noise_next             ;3
    ; 2+2+6*5+3 = 37c
    
.noise_update

    lda     noise_acc+0            ;3
    adc     #<2174                 ;2 // utz's rand seed
    sta     noise_acc+0            ;3
    lda     noise_acc+1            ;3
    adc     noise_add_hi           ;3
    cmp     #$80                   ;2
    rol     a                      ;2
    sta     noise_acc+1            ;3
    inc     noise_add_hi           ;5
    ldy     noise_pitch            ;3
    ;32c // 2+3+32 = 37c
    
.noise_next

    lda     noise_volume           ;3
    cmp     noise_acc+1            ;3 C=0 --> sound off, C=1 --> sound on
    lda     #SPEAKER_OFF           ;2
    adc     #0                     ;2
    sta     SHEILA_MISC_CONTROL    ;4
    ;14c

    dex                            ;2
    bne     noise_loop             ;2/3
    ;~5c

; ------------------------------------------------------------------------------------------------

    ldy     tmp_y

.skip_percussion

    tya
    clc
    adc     pattern_ptr+0
    sta     pattern_ptr+0
    bcc     L8
    inc     pattern_ptr+1
.L8

if HAS_SAMPLES=1
    lda     sample_mask
    sta     sample_bit
endif

.sound_loop_0

    ldx     #CYCLES
    ldy     #0                    ;sample ptr inside the loop

 ; -- (37c)+120c ------------------------------------------------------------------------------------------  
.sound_loop

if HAS_SAMPLES=1

    lda     (sample_ptr),y        ;5+ // it's okay if sample_ptr is not valid
    and     sample_bit            ;3    
    beq     spkr_off              ;2/3
    lda     #SPEAKER_ON           ;2
    bne     spkr_set              ;3 jump always
.spkr_off
    lda     #SPEAKER_OFF          ;2
.spkr_set
    sta     sample_out            ;3
    ;16

    lda     sample_mask           ;3 preload
    lsr     sample_bit            ;5
    lsr     sample_bit            ;5 // drop every other sample bit!
    beq     sample_inc            ;2/3
    sta     temp                  ;3 dummy
    bne     sample_next           ;3 jump always
.sample_inc
    sta     sample_bit            ;3
    iny                           ;2
.sample_next
    ;21

    ;16+21=37
endif

    lda     #0                    ;2
    sta     ch_mixer              ;3
    ;5

    lda     ch0_acc+0             ;3
.sm_ch0_add0
    adc     #0                    ;2 selfmod
    sta     ch0_acc+0             ;3
    lda     ch0_acc+1             ;3
.sm_ch0_add1
    adc     #0                    ;2 selfmod
    rol     ch_mixer              ;5
    sta     ch0_acc+1             ;3
    ;21
    
    lda     ch1_acc+0             ;3
.sm_ch1_add0
    adc     #0                    ;2 selfmod
    sta     ch1_acc+0             ;3
    lda     ch1_acc+1             ;3
.sm_ch1_add1
    adc     #0                    ;2 selfmod
    rol     ch_mixer              ;5
    sta     ch1_acc+1             ;3
    ;21
    
    lda     ch2_acc+0             ;3
.sm_ch2_add0
    adc     #0                    ;2 selfmod
    sta     ch2_acc+0             ;3
    lda     ch2_acc+1             ;3
.sm_ch2_add1
    adc     #0                    ;2 selfmod
    rol     ch_mixer              ;5
    sta     ch2_acc+1             ;3
    ;21

    lda     ch3_acc+0             ;3
.sm_ch3_add0
    adc     #0                    ;2 selfmod
    sta     ch3_acc+0             ;3
    lda     ch3_acc+1             ;3
.sm_ch3_add1
    adc     #0                    ;2 selfmod
    rol     ch_mixer              ;5
    cmp     #$80                  ;2 needed for rol a, to match Z80's srl h
    ;20

.noise_opcode
    nop                           ;2 nop or rol a, self-modifying code here!
    sta     ch3_acc+1             ;3
    ;5
    
    ;(37)+5+21+21+21+20+5 = (37)+93

    lda     ch_acc                ;3
    clc                           ;2
    adc     ch_mixer              ;3
    bne     speaker_on            ;2/3
if HAS_SAMPLES=1
    nop                           ;2 dummy
    lda     sample_out            ;3
else
    sta     temp                  ;3 dummy
    lda     #SPEAKER_OFF          ;2
endif
    bne     set_speaker           ;3 jump always
.speaker_on
    adc     #$ff                  ;2
    sta     ch_acc                ;3
    lda     #SPEAKER_ON           ;2
.set_speaker
    sta     SHEILA_MISC_CONTROL   ;4
    ;22

    dex                           ;2
    bne     sound_loop            ;2/3
    ;~5

    ;(37)+93+22+5 = (37)+120

; ------------------------------------------------------------------------------------------------

if HAS_SAMPLES=1

    dey
    lda     (sample_ptr),y        ; it's okay if sample_ptr is not valid
    cmp     #EOS
    bne     sample_no_stop

    lda     #0                    ;disable sample reading
    sta     sample_mask

.sample_no_stop

    tya
    sec                           ; (!)
    adc     sample_ptr+0
    sta     sample_ptr+0
    bcc     L13
    inc     sample_ptr+1
.L13
endif

    dec     row_length
if HAS_SAMPLES=1
    beq     L14
    jmp     sound_loop_0
.L14
else
    bne     sound_loop_0
endif
    jmp     play_loop

if HAS_SAMPLES=1
.sample_list_lo
    equb    lo(sample_1)
    equb    lo(sample_2)
    equb    lo(sample_3)
    equb    lo(sample_4)
    equb    lo(sample_5)
    equb    lo(sample_6)
    equb    lo(sample_7)

.sample_list_hi
    equb    hi(sample_1)
    equb    hi(sample_2)
    equb    hi(sample_3)
    equb    hi(sample_4)
    equb    hi(sample_5)
    equb    hi(sample_6)
    equb    hi(sample_7)
endif

if HAS_SAMPLES=1
  ; end of sample marker (EOS)
  ; any combination of bit6/4/2/0 that is NOT a sample value in the track

  if TRACK=1   
    EOS=%00010101
    INCLUDE "tracks\lets_go.track.6502" ; has samples
  elif TRACK=2
    EOS=%00010101
    INCLUDE "tracks\high_orbit.track.6502" ; has samples (plays too fast?)
  elif TRACK=3
    EOS=%00010101
    INCLUDE "tracks\dj.h0ffman.squat_party.track.6502" ; has samples
  else
    error "No track selected!"
  endif

else

    INCLUDE "tracks\geostorm.track.6502" ; no samples (no EOS needed)

endif

.end

SAVE "SQUATM",start,end
PUTBASIC "LOADER.txt","LOADER"
PUTFILE  "!BOOT.txt","!BOOT",0,0
